/*
 * Copyright 2022 Loophole Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 	   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by fRPC Go v0.7.0, DO NOT EDIT.
// source: rpc/build/build.proto

package build

import (
	"errors"
	"github.com/loopholelabs/polyglot-go"

	"context"
	"crypto/tls"
	"github.com/loopholelabs/frisbee-go"
	"github.com/loopholelabs/frisbee-go/pkg/packet"
	"github.com/rs/zerolog"

	"sync"
)

var (
	NilDecode = errors.New("cannot decode into a nil root struct")
)

type BuildStreamType uint32

const (
	BuildERROR  = BuildStreamType(0)
	BuildCLOSE  = BuildStreamType(1)
	BuildSTDOUT = BuildStreamType(2)
	BuildSTDERR = BuildStreamType(3)
	BuildOUTPUT = BuildStreamType(4)
)

type BuildStreamPacket struct {
	error error
	flags uint8

	Type BuildStreamType
	Data []byte
}

func NewBuildStreamPacket() *BuildStreamPacket {
	return &BuildStreamPacket{}
}

func (x *BuildStreamPacket) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BuildStreamPacket) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Uint32(uint32(x.Type)).Bytes(x.Data)
	}
}

func (x *BuildStreamPacket) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BuildStreamPacket) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	var TypeTemp uint32
	TypeTemp, err = d.Uint32()
	x.Type = BuildStreamType(TypeTemp)
	if err != nil {
		return err
	}
	x.Data, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	return nil
}

type BuildDependency struct {
	error error
	flags uint8

	Name    string
	Version string
}

func NewBuildDependency() *BuildDependency {
	return &BuildDependency{}
}

func (x *BuildDependency) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BuildDependency) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Name).String(x.Version)
	}
}

func (x *BuildDependency) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BuildDependency) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Name, err = d.String()
	if err != nil {
		return err
	}
	x.Version, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type BuildBuildConfig struct {
	error error
	flags uint8

	Language     string
	Dependencies []*BuildDependency
}

func NewBuildBuildConfig() *BuildBuildConfig {
	return &BuildBuildConfig{}
}

func (x *BuildBuildConfig) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BuildBuildConfig) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Language)
		polyglot.Encoder(b).Slice(uint32(len(x.Dependencies)), polyglot.AnyKind)
		for _, v := range x.Dependencies {
			v.Encode(b)
		}
	}
}

func (x *BuildBuildConfig) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BuildBuildConfig) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Language, err = d.String()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Dependencies)) != sliceSize {
		x.Dependencies = make([]*BuildDependency, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.Dependencies[i] == nil {
			x.Dependencies[i] = NewBuildDependency()
		}
		err = x.Dependencies[i].decode(d)
		if err != nil {
			return err
		}
	}
	return nil
}

type BuildScaleFile struct {
	error error
	flags uint8

	Name        string
	Input       []byte
	BuildConfig *BuildBuildConfig
}

func NewBuildScaleFile() *BuildScaleFile {
	return &BuildScaleFile{
		BuildConfig: NewBuildBuildConfig(),
	}
}

func (x *BuildScaleFile) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BuildScaleFile) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Name).Bytes(x.Input)
		x.BuildConfig.Encode(b)
	}
}

func (x *BuildScaleFile) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BuildScaleFile) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Name, err = d.String()
	if err != nil {
		return err
	}
	x.Input, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	if x.BuildConfig == nil {
		x.BuildConfig = NewBuildBuildConfig()
	}
	err = x.BuildConfig.decode(d)
	if err != nil {
		return err
	}
	return nil
}

type BuildRequest struct {
	error error
	flags uint8

	Token     string
	ScaleFile *BuildScaleFile
}

func NewBuildRequest() *BuildRequest {
	return &BuildRequest{
		ScaleFile: NewBuildScaleFile(),
	}
}

func (x *BuildRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BuildRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Token)
		x.ScaleFile.Encode(b)
	}
}

func (x *BuildRequest) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BuildRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Token, err = d.String()
	if err != nil {
		return err
	}
	if x.ScaleFile == nil {
		x.ScaleFile = NewBuildScaleFile()
	}
	err = x.ScaleFile.decode(d)
	if err != nil {
		return err
	}
	return nil
}

type BuildResponse struct {
	error error
	flags uint8

	StreamID uint32
}

func NewBuildResponse() *BuildResponse {
	return &BuildResponse{}
}

func (x *BuildResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BuildResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Uint32(x.StreamID)
	}
}

func (x *BuildResponse) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BuildResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.StreamID, err = d.Uint32()
	if err != nil {
		return err
	}
	return nil
}

type Service interface {
	Build(context.Context, *BuildRequest) (*BuildResponse, error)
}

const connectionContextKey int = 1000

func SetCloseFlag(flags uint8, close bool) uint8 {
	return flags | 0x1
}
func HasCloseFlag(flags uint8) bool {
	return flags&1 == 1
}
func SetErrorFlag(flags uint8, error bool) uint8 {
	return flags | 0x2
}
func HasErrorFlag(flags uint8) bool {
	return flags&(1<<1) == 1
}

type ServerMap[T any] struct {
	servers map[uint16]*T
	closed  bool
	mu      sync.Mutex
}

func NewServerMap[T any]() *ServerMap[T] {
	return &ServerMap[T]{servers: make(map[uint16]*T)}
}

type Server struct {
	*frisbee.Server
	onClosed func(*frisbee.Async, error)
}

func NewServer(service Service, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
	var s *Server
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBuildRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BuildResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = service.Build(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	var fsrv *frisbee.Server
	var err error
	if tlsConfig != nil {
		fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	fsrv.ConnContext = func(ctx context.Context, conn *frisbee.Async) context.Context {
		return context.WithValue(ctx, connectionContextKey, conn)
	}
	s, err = &Server{
		Server: fsrv,
	}, nil

	fsrv.SetOnClosed(func(async *frisbee.Async, err error) {
		if s.onClosed != nil {
			s.onClosed(async, err)
		}
	})

	return s, err
}

func (s *Server) SetOnClosed(f func(*frisbee.Async, error)) error {
	if f == nil {
		return frisbee.OnClosedNil
	}
	s.onClosed = f
	return nil
}

type subServiceClient struct {
	client          *frisbee.Client
	nextBuild       uint16
	nextBuildMu     sync.RWMutex
	inflightBuild   map[uint16]chan *BuildResponse
	inflightBuildMu sync.RWMutex
}
type Client struct {
	*frisbee.Client
	Service *subServiceClient
}

func NewClient(tlsConfig *tls.Config, logger *zerolog.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.Service.inflightBuildMu.RLock()
		if ch, ok := c.Service.inflightBuild[incoming.Metadata.Id]; ok {
			c.Service.inflightBuildMu.RUnlock()
			res := NewBuildResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.Service.inflightBuildMu.RUnlock()
		}
		return
	}
	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.Service = new(subServiceClient)
	c.Service.client = c.Client
	c.Service.nextBuildMu.Lock()
	c.Service.nextBuild = 0
	c.Service.nextBuildMu.Unlock()
	c.Service.inflightBuild = make(map[uint16]chan *BuildResponse)
	return c, nil
}

func (c *subServiceClient) Build(ctx context.Context, req *BuildRequest) (res *BuildResponse, err error) {
	ch := make(chan *BuildResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 10

	c.nextBuildMu.Lock()
	c.nextBuild += 1
	id := c.nextBuild
	c.nextBuildMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightBuildMu.Lock()
	c.inflightBuild[id] = ch
	c.inflightBuildMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightBuildMu.Lock()
	delete(c.inflightBuild, id)
	c.inflightBuildMu.Unlock()
	packet.Put(p)
	return
}

type CloseError struct {
	err error
}

func NewCloseError(err error) CloseError {
	return CloseError{err: err}
}

func (e CloseError) Error() string {
	return e.err.Error()
}
